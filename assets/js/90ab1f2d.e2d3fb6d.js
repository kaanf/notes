"use strict";(self.webpackChunkdocu_tutorial=self.webpackChunkdocu_tutorial||[]).push([[595],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=c(n),u=r,h=d["".concat(l,".").concat(u)]||d[u]||p[u]||o;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1141:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return m},default:function(){return d}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={author:"kaanf",authorTitle:"Android Developer",authorURL:"https://github.com/kaanf",authorImageURL:"https://github.com/kaanf.png",tags:["Data Structures","Kotlin","Programming"]},l="list performance",c={unversionedId:"programming/data structures/list-performance",id:"programming/data structures/list-performance",isDocsHomePage:!1,title:"list performance",description:"Aside from being a random-access collection, there are other areas of performance that are of interest on how well or poorly does the data structure fare when the amount of data it contains needs to grow. For lists, this varies on two factors.",source:"@site/notes/programming/data structures/list-performance.md",sourceDirName:"programming/data structures",slug:"/programming/data structures/list-performance",permalink:"/notes/programming/data structures/list-performance",editUrl:"https://github.com/kaanf/personal-notes/edit/main/website/notes/programming/data structures/list-performance.md",tags:[{label:"Data Structures",permalink:"/notes/tags/data-structures"},{label:"Kotlin",permalink:"/notes/tags/kotlin"},{label:"Programming",permalink:"/notes/tags/programming"}],version:"current",lastUpdatedBy:"kaanf",lastUpdatedAt:1633651110,formattedLastUpdatedAt:"10/8/2021",frontMatter:{author:"kaanf",authorTitle:"Android Developer",authorURL:"https://github.com/kaanf",authorImageURL:"https://github.com/kaanf.png",tags:["Data Structures","Kotlin","Programming"]},sidebar:"tutorialSidebar",previous:{title:"linked list",permalink:"/notes/programming/data structures/linked-list"},next:{title:"collection interfaces",permalink:"/notes/programming/kotlin/collection-interfaces"}},m=[{value:"Insertion location",id:"insertion-location",children:[]},{value:"Capacity",id:"capacity",children:[]}],p={toc:m};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"list-performance"},"list performance"),(0,o.kt)("p",null,"Aside from being a random-access collection, there are other areas of performance that are of interest on how well or poorly does the data structure fare when the amount of data it contains needs to grow. For lists, this varies on two factors."),(0,o.kt)("h3",{id:"insertion-location"},"Insertion location"),(0,o.kt)("p",null,"The first factor is one in which you choose to insert the new element inside the list. The most efficient scenario for adding an element to a list is to append it at the ",(0,o.kt)("inlineCode",{parentName:"p"},"end of the list"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val mutablePlaces = mutableListOf("Paris", "London", "Bucharest")\nmutablePlaces.add("Budapest")\nprintln(mutablePlaces)\n')),(0,o.kt)("p",null,"Inserting ",(0,o.kt)("strong",{parentName:"p"},'"Budapest"')," using ",(0,o.kt)("inlineCode",{parentName:"p"},"add()")," places the string at the end of the list. This is a constant-time operation, meaning the time it takes to perform this operation stays the same no matter how large the list becomes. However, there may come a time that you need to insert an element in a particular location, such as in the middle of the list. To help illustrate, ",(0,o.kt)("em",{parentName:"p"},"consider the following analogy"),". "),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"You\u2019re standing in line for the movies. Someone new comes along to join the lineup. If they just go to the end of the line, nobody will even notice the newcomer. But, if the newcomer tried to insert himself into the middle of the line, he would have to convince half the lineup to shuffle back to make room. And if he were terribly rude, he may try to insert himself at the head of the line. This is the worstcase scenario because every single person in the lineup would need to shuffle back to make room for this new person in front!"))),(0,o.kt)("p",null,"This is exactly how lists work. Inserting new elements from anywhere aside from the end will force elements to shift back to make room for the new element:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'mutablePlaces.add(0, "Kiev")\n')),(0,o.kt)("p",null,"To be precise, every element must shift back by ",(0,o.kt)("strong",{parentName:"p"},"one index"),". If we consider the number of items in the list to be n, this would take ",(0,o.kt)("inlineCode",{parentName:"p"},"n steps"),". The time for this operation grows as the",(0,o.kt)("strong",{parentName:"p"}," number of elements in the list grows"),". If the number of elements in the list ",(0,o.kt)("strong",{parentName:"p"},"doubles"),", the time required for this add operation will also ",(0,o.kt)("inlineCode",{parentName:"p"},"double"),"."),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"If inserting elements in front of a collection is a common operation for your program, you may want to consider a ",(0,o.kt)("strong",{parentName:"p"},"different data structure to hold your data"),"."))),(0,o.kt)("h3",{id:"capacity"},"Capacity"),(0,o.kt)("p",null,"The second factor that determines the speed of insertion is the list\u2019s capacity. Underneath the hood, Kotlin lists are allocated with a predetermined amount of space for its elements. If you try to add new elements to a list that is already at maximum capacity, the List must restructure itself to make more room for more elements. This is done by copying all the current elements of the list in a new and bigger container in memory.\nHowever, this comes at a ",(0,o.kt)("inlineCode",{parentName:"p"},"cost.")," Each element of the list has to be accessed and copied. ",(0,o.kt)("strong",{parentName:"p"},"This means that any insertion, even at the end, could take n steps to complete if a copy is made.")),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Standard Library employs a strategy that minimizes the times this copying needs to occur. Each time it runs out of storage and needs to copy, it doubles the capacity."))))}d.isMDXComponent=!0}}]);